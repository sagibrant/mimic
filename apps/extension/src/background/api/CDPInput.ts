/**
 * @copyright 2026 Sagi All Rights Reserved.
 * @author: Sagi <sagibrant@hotmail.com>
 * @license Apache-2.0
 * @file CDPInput.ts
 * @description 
 * Provide wrapper class for mouse and keyboard in Chrome DevTool Protocol APIs
 *
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Utils, KeyboardModifier, KeyDefinitionUtils } from "@mimic-sdk/core";
import { ChromeDevToolsProtocol } from "./ChromeDevToolsProtocol";

/**
 * Modifier key bit flags for CDP events.
 */
export enum CDPModifiers {
  None = 0,
  Alt = 1,
  Ctrl = 2,
  Meta_Command = 4,
  Shift = 8
}

/**
 * Types of key events in CDP.
 */
export type CDPKeyEventType = 'keyDown' | 'keyUp' | 'rawKeyDown' | 'char';

/**
 * Options for configuring a CDP keyboard event.
 * Used with Input.dispatchKeyEvent.
 */
export interface CDPKeyEventOption {
  /**
   * Type of the key event.  
   * Allowed Values: keyDown, keyUp, rawKeyDown, char
   */
  type: CDPKeyEventType;
  /**
   * Bit field representing pressed modifier keys. 
   * Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
   * @defaultValue 0 = CDPModifiers.None;
   */
  modifiers?: number;
  /**
   * Time at which the event occurred.
   */
  timestamp?: number;
  /**
   * Text as generated by processing a virtual key code with a keyboard layout. 
   * Not needed for for keyUp and rawKeyDown events (default: "")
   * @defaultValue ""
   */
  text?: string;
  /**
   * Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). 
   * Useful for shortcut (accelerator) key handling (default: "").
   * @defaultValue ""
   */
  unmodifiedText?: string;
  /**
   * Unique key identifier (e.g., 'U+0041') (default: "").
   */
  keyIdentifier?: string;
  /**
   * Unique DOM defined string value for each physical key (e.g., 'KeyA') (default: "").
   * @defaultValue ""
   */
  code?: string;
  /**
   * Unique DOM defined string value describing the meaning of the key in the context of active modifiers, keyboard layout, etc (e.g., 'AltGr') (default: "").
   * @defaultValue ""
   */
  key?: string;
  /**
   * Windows virtual key code (default: 0).
   * @defaultValue 0
   */
  windowsVirtualKeyCode?: number;
  /**
   * Native virtual key code (default: 0).
   * @defaultValue 0
   */
  nativeVirtualKeyCode?: number;
  /**
   * Whether the event was generated from auto repeat (default: false).
   * @defaultValue false
   */
  autoRepeat?: boolean;
  /**
   * Whether the event was generated from the keypad (default: false).
   * @defaultValue false
   */
  isKeypad?: boolean;
  /**
   * Whether the event was a system key event (default: false).
   * @defaultValue false
   */
  isSystemKey?: boolean;
  /**
   * Whether the event was from the left or right side of the keyboard. 
   * 1=Left, 2=Right (default: 0).
   * @defaultValue 0
   */
  location?: number;
  /**
   * Experimental
   * Editing commands to send with the key event (e.g., 'selectAll') (default: []). 
   * These are related to but not equal the command names used in document.execCommand and NSStandardKeyBindingResponding. 
   * See https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/core/editing/commands/editor_command_names.h for valid command names.
  * @defaultValue []
   */
  commands?: string[];
}

/**
 * Wrapper for CDP keyboard operations.
 * Provides high-level methods for simulating keyboard input.
 */
export class CDPKeyboard {
  private _tabId: number;
  private _cdp: ChromeDevToolsProtocol;
  /**
   * Set of currently pressed modifier keys.
   */
  private _pressedModifiers = new Set<KeyboardModifier>();
  /**
   * Set of currently pressed keys (by code).
   */
  private _pressedKeys = new Set<string>();
  /**
   * Create a keyboard controller for a tab.
   * @param tabId - Tab ID to control
   * @param cdp - CDP instance
   */
  constructor(tabId: number, cdp: ChromeDevToolsProtocol) {
    this._tabId = tabId;
    this._cdp = cdp;
    this._pressedModifiers = new Set<KeyboardModifier>();
    this._pressedKeys = new Set<string>();
  }

  get pressedModifiers(): Set<KeyboardModifier> {
    return this._pressedModifiers;
  }

  toModifiersMask(pressedModifiers: Set<KeyboardModifier>): number {
    let modifiers: number = CDPModifiers.None;
    if (pressedModifiers.has('Alt')) { modifiers |= CDPModifiers.Alt; }
    if (pressedModifiers.has('Control')) { modifiers |= CDPModifiers.Ctrl; }
    if (pressedModifiers.has('Meta')) { modifiers |= CDPModifiers.Meta_Command; }
    if (pressedModifiers.has('Shift')) { modifiers |= CDPModifiers.Shift; }
    return modifiers;
  }

  async down(key: string, commands?: string[]): Promise<void> {
    if (Utils.isNullOrUndefined(key)) {
      throw new Error('Invalid key argument.');
    }
    const description = KeyDefinitionUtils.getKeyDescription(key, this._pressedModifiers);
    if (Utils.isNullOrUndefined(description)) {
      throw new Error(`Unknown key - ${key}`);
    }
    const autoRepeat = this._pressedKeys.has(description.code);
    this._pressedKeys.add(description.code);
    if (KeyDefinitionUtils.isKeyboardModifier(description.key)) {
      this._pressedModifiers.add(description.key);
    }
    const type: CDPKeyEventType = description.text ? "keyDown" : "rawKeyDown";
    const eventOptions: CDPKeyEventOption = {
      type: type,
      modifiers: this.toModifiersMask(this._pressedModifiers),
      windowsVirtualKeyCode: description.keyCodeWithoutLocation,
      code: description.code,
      key: description.key,
      text: description.text,
      unmodifiedText: description.text,
      autoRepeat: autoRepeat,
      location: description.location,
      isKeypad: description.location === 3,
      commands
    };
    await this._cdp.sendCommand(this._tabId, "Input.dispatchKeyEvent", eventOptions);
  }

  async up(key: string, commands?: string[]): Promise<void> {
    if (Utils.isNullOrUndefined(key)) {
      throw new Error('Invalid key argument.');
    }
    const description = KeyDefinitionUtils.getKeyDescription(key, this._pressedModifiers);
    if (Utils.isNullOrUndefined(description)) {
      throw new Error(`Unknown key - ${key}`);
    }
    if (KeyDefinitionUtils.isKeyboardModifier(description.key)) {
      this._pressedModifiers.delete(description.key);
    }
    this._pressedKeys.delete(description.code);
    const eventOptions: CDPKeyEventOption = {
      type: "keyUp",
      modifiers: this.toModifiersMask(this._pressedModifiers),
      key: description.key,
      windowsVirtualKeyCode: description.keyCodeWithoutLocation,
      code: description.code,
      location: description.location,
      commands
    };
    await this._cdp.sendCommand(this._tabId, "Input.dispatchKeyEvent", eventOptions);
  }

  async selectAll(): Promise<void> {
    const downEventOptions: CDPKeyEventOption = {
      type: "keyDown",
      commands: ["selectAll"]
    };
    await this._cdp.sendCommand(this._tabId, "Input.dispatchKeyEvent", downEventOptions);
    const upEventOptions: CDPKeyEventOption = {
      type: "keyUp",
      commands: ["selectAll"]
    };
    await this._cdp.sendCommand(this._tabId, "Input.dispatchKeyEvent", upEventOptions);
  }

  async insertText(text: string): Promise<void> {
    if (Utils.isNullOrUndefined(text)) {
      throw new Error('Invalid text argument.');
    }
    await this._cdp.sendCommand(this._tabId, "Input.insertText", { text: text });
  }

}

/**
 * Types of mouse events in CDP.
 */
export type CDPMouseEventType = 'mousePressed' | 'mouseReleased' | 'mouseMoved' | 'mouseWheel';

/**
 * Types of mouse buttons in CDP.
 */
export type CDPMouseButton = 'none' | 'left' | 'middle' | 'right' | 'back' | 'forward';

/**
 * Options for configuring a CDP mouse event.
 * Used with Input.dispatchMouseEvent.
 */
export interface CDPMouseEventOption {
  /** 
   * Type of the mouse event. 
   * Allowed Values: mousePressed, mouseReleased, mouseMoved, mouseWheel
   * @defaultValue "mouseMoved"
   */
  type: CDPMouseEventType;
  /**
   * X coordinate of the event relative to the main frame's viewport in CSS pixels.
   */
  x: number;
  /**
   * Y coordinate of the event relative to the main frame's viewport in CSS pixels. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport.
   */
  y: number;
  /**
   * Bit field representing pressed modifier keys. 
   * Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0).
   * @defaultValue 0 = CDPModifiers.None;
   */
  modifiers?: CDPModifiers;
  /**
   * Time at which the event occurred.
   */
  timestamp?: number;
  /**
   * Mouse button (default: "none"). 
   * Allowed Values: none, left, middle, right, back, forward
   * @defaultValue "none"
   */
  button?: CDPMouseButton;
  /**
   * A number indicating which buttons are pressed on the mouse when a mouse event is triggered. 
   * Left=1, Right=2, Middle=4, Back=8, Forward=16, None=0.
   * @defaultValue 0
   */
  buttons?: number;
  /**
   * Number of times the mouse button was clicked (default: 0).
   * @defaultValue 0
   */
  clickCount?: number;
  /**
   * The normalized pressure, which has a range of [0,1] (default: 0).
   * @defaultValue 0
   */
  force?: number;
  /**
   * The normalized tangential pressure, which has a range of [-1,1] (default: 0).
   * @defaultValue 0
   */
  tangentialPressure?: number;
  /**
   * The plane angle between the Y-Z plane and the plane containing both the stylus axis and the Y axis, in degrees of the range [-90,90], a positive tiltX is to the right (default: 0).
   * @defaultValue 0
   */
  tiltX?: number;
  /**
   * The plane angle between the X-Z plane and the plane containing both the stylus axis and the X axis, in degrees of the range [-90,90], a positive tiltY is towards the user (default: 0).
   * @defaultValue 0
   */
  tiltY?: number;
  /**
   * The clockwise rotation of a pen stylus around its own major axis, in degrees in the range [0,359] (default: 0).
   * @defaultValue 0
   */
  twist?: number;
  /**
   * X delta in CSS pixels for mouse wheel event (default: 0).
   * @defaultValue 0
   */
  deltaX?: number;
  /**
   * Y delta in CSS pixels for mouse wheel event (default: 0).
   * @defaultValue 0
   */
  deltaY?: number;
  /**
   * Pointer type (default: "mouse"). Allowed Values: mouse, pen
   * @defaultValue "mouse"
   */
  pointerType?: 'mouse' | 'pen';
}

/**
 * Wrapper for CDP mouse operations.
 * Provides high-level methods for simulating mouse input.
 */
export class CDPMouse {
  private _tabId: number;
  private _cdp: ChromeDevToolsProtocol;
  private _x: number;
  private _y: number;
  private _lastPressedButton: CDPMouseButton = 'none';
  private _pressedButtons = new Set<CDPMouseButton>();
  private _cdpKeyboard: CDPKeyboard;

  /**
   * Create a mouse controller for a tab.
   * @param tabId - Tab ID to control
   * @param cdp - CDP instance
   */
  constructor(tabId: number, cdp: ChromeDevToolsProtocol, keyboard: CDPKeyboard) {
    this._tabId = tabId;
    this._cdp = cdp;
    this._x = 0;
    this._y = 0;
    this._lastPressedButton = 'none';
    this._pressedButtons = new Set<CDPMouseButton>();
    this._cdpKeyboard = keyboard;
  }

  toButtonsMask(pressedButtons: Set<CDPMouseButton>): number {
    let buttons: number = 0; // 'none'
    if (pressedButtons.has('left')) { buttons |= 1; }
    if (pressedButtons.has('right')) { buttons |= 2; }
    if (pressedButtons.has('middle')) { buttons |= 4; }
    if (pressedButtons.has('back')) { buttons |= 8; }
    if (pressedButtons.has('forward')) { buttons |= 16; }
    return buttons;
  }

  private getModifiersMask(): number {
    return this._cdpKeyboard.toModifiersMask(this._cdpKeyboard.pressedModifiers);
  }

  /**
   * Reset mouse position to (0,0).
   */
  async reset(): Promise<void> {
    await this.move(0, 0);
    this._lastPressedButton = 'none';
    this._pressedButtons = new Set<CDPMouseButton>();
  }

  /**
   * Move the mouse to coordinates.
  * @param {number} [x] - Horizontal coordinate of the mouse position, relative to viewport (in pixels).
  * @param {number} [y] - Vertical coordinate of the mouse position, relative to viewport (in pixels). 
   */
  async move(x: number, y: number, steps: number = 1): Promise<void> {
    const fromX = this._x;
    const fromY = this._y;
    this._x = x;
    this._y = y;
    const eventOptions: CDPMouseEventOption = {
      type: "mouseMoved",
      x: this._x,
      y: this._y,
      button: this._lastPressedButton,
      buttons: this.toButtonsMask(this._pressedButtons),
      modifiers: this.getModifiersMask(),
      force: this._pressedButtons.size > 0 ? 0.5 : 0,
    };
    for (let i = 1; i <= steps; i++) {
      // Easing for natural acceleration/deceleration
      const t = i / steps;
      const easeT = t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      // Update viewport-relative position
      const currentX = fromX + (this._x - fromX) * easeT;
      const currentY = fromY + (this._y - fromY) * easeT;
      const stepOptions = Utils.deepClone(eventOptions);
      stepOptions.x = Math.round(currentX);
      stepOptions.y = Math.round(currentY);
      await this._cdp.sendCommand(this._tabId, "Input.dispatchMouseEvent", stepOptions);
    }
  }

  /**
   * Simulate mouse down event.
   * @param {Object} [options] - Configuration options for the mouse event simulation.
   * @param {number} [options.x] - Horizontal coordinate of the mouse position, relative to viewport (in pixels).
   * @param {number} [options.y] - Vertical coordinate of the mouse position, relative to viewport (in pixels).
   * @param {CDPMouseButton} [options.button=left] - The mouse button to simulate (e.g., left, right, middle)
   * @param {number} [options.clickCount=1] - Number of clicks to simulate (1 for single click, 2 for double click)
   */
  async down(options?: {
    button?: CDPMouseButton;
    clickCount?: number;
  }): Promise<void> {
    const { button = 'left', clickCount = 1 } = options || {};
    this._lastPressedButton = button;
    this._pressedButtons.add(button);
    const eventOptions: CDPMouseEventOption = {
      type: "mousePressed",
      x: this._x,
      y: this._y,
      button: this._lastPressedButton,
      buttons: this.toButtonsMask(this._pressedButtons),
      modifiers: this.getModifiersMask(),
      clickCount: clickCount,
      force: this._pressedButtons.size > 0 ? 0.5 : 0,
    };
    await this._cdp.sendCommand(this._tabId, "Input.dispatchMouseEvent", eventOptions);
  }

  /**
   * Simulate mouse up event.
   * @param {Object} [options] - Configuration options for the mouse event simulation.
   * @param {CDPMouseButton} [options.button=left] - The mouse button to simulate (e.g., left, right, middle)
   * @param {number} [options.clickCount=1] - Number of clicks to simulate (1 for single click, 2 for double click)
   */
  async up(options?: {
    button?: CDPMouseButton;
    clickCount?: number;
  }): Promise<void> {
    const { button = 'left', clickCount = 1 } = options || {};
    this._lastPressedButton = 'none';
    this._pressedButtons.delete(button);
    const eventOptions: CDPMouseEventOption = {
      type: "mouseReleased",
      x: this._x,
      y: this._y,
      button: button, // button is released, so it is not in this._pressedButtons
      buttons: this.toButtonsMask(this._pressedButtons),
      modifiers: this.getModifiersMask(),
      clickCount: clickCount
    };
    await this._cdp.sendCommand(this._tabId, "Input.dispatchMouseEvent", eventOptions);
  }

  /**
   * Simulate mouse wheel event.
   * @param {number} [options.deltaX=0] - Horizontal scroll delta (positive for rightward scroll, negative for leftward). Defaults to `0`.
   * @param {number} [options.deltaY=100] - Vertical scroll delta (positive for downward scroll, negative for upward). Defaults to `100`.
   */
  async wheel(options?: {
    deltaX?: number;
    deltaY?: number;
  }): Promise<void> {
    const { deltaX = 0, deltaY = 100 } = options || {};
    const eventOptions: CDPMouseEventOption = {
      type: "mouseWheel",
      x: this._x,
      y: this._y,
      modifiers: this.getModifiersMask(),
      deltaX: deltaX,
      deltaY: deltaY
    };
    await this._cdp.sendCommand(this._tabId, "Input.dispatchMouseEvent", eventOptions);
  }
};


export class CDPTouchscreen {
  private _tabId: number;
  private _cdp: ChromeDevToolsProtocol;
  private _cdpKeyboard: CDPKeyboard;

  /**
   * Create a touchscreen controller for a tab.
   * @param tabId - Tab ID to control
   * @param cdp - CDP instance
   * @param keyboard - CDPKeyboard instance for modifier keys
   */
  constructor(tabId: number, cdp: ChromeDevToolsProtocol, keyboard: CDPKeyboard) {
    this._tabId = tabId;
    this._cdp = cdp;
    this._cdpKeyboard = keyboard;
  }

  async tap(x: number, y: number): Promise<void> {
    await this._cdp.sendCommand(this._tabId, "Input.dispatchTouchEvent", {
      type: 'touchStart',
      touchPoints: [{ x: Math.round(x), y: Math.round(y) }],
      modifiers: this._cdpKeyboard.toModifiersMask(this._cdpKeyboard.pressedModifiers)
    });
    await this._cdp.sendCommand(this._tabId, "Input.dispatchTouchEvent", {
      type: 'touchEnd',
      touchPoints: [],
      modifiers: this._cdpKeyboard.toModifiersMask(this._cdpKeyboard.pressedModifiers)
    });
  }

}

